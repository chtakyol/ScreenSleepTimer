# Product Requirements Document: CI/CD Pipeline for Android Build Variants

## Introduction/Overview

This document outlines the requirements for implementing a comprehensive CI/CD pipeline for the SleepTimer Android application using GitHub Actions and Fastlane. The pipeline will support three distinct build variants (Test, Staging, and Release) with automated building, testing, and distribution workflows.

**Problem Statement:** Currently, the SleepTimer app lacks automated build and distribution processes for different environments. Manual builds are error-prone, time-consuming, and don't provide consistent testing across development stages. Teams need a reliable way to test features internally, conduct pre-production validation, and release to production with confidence.

**Goal:** Establish a fully automated CI/CD pipeline that builds, tests, and distributes Android app variants for different environments, reducing manual effort and improving release quality.

## Goals

1. **Automate Build Process:** Eliminate manual building for test, staging, and production environments
2. **Environment Separation:** Provide isolated build variants with distinct configurations for testing vs. production
3. **Streamline Distribution:** Automatically distribute test builds via Firebase App Distribution and production builds to Google Play Store
4. **Quality Assurance:** Integrate automated testing gates to catch issues before distribution
5. **Developer Productivity:** Reduce time from code commit to testable build from hours to minutes
6. **Production Safety:** Prevent accidental production deployments with manual approval gates

## User Stories

### As a Developer
- I want test builds to be automatically created when I open a pull request, so I can validate my changes before merging
- I want to receive test builds via Firebase App Distribution, so I can install and test on my device quickly
- I want the pipeline to use test AdMob IDs, so I don't risk my account with invalid ad traffic during development

### As a QA Tester
- I want staging builds to be automatically deployed when code is merged to the develop branch, so I can test new features in a production-like environment
- I want to access builds through Firebase App Distribution, so I can test on multiple devices easily
- I want staging builds to have crash reporting enabled, so I can provide detailed bug reports

### As a Product Owner/Release Manager
- I want release builds to be automatically generated when code is pushed to the main branch, so the build process is consistent
- I want the ability to manually approve Play Store releases, so I can control when users receive updates
- I want production builds to use real AdMob IDs and be fully optimized, so users get the best experience

### As a Team Lead
- I want different build variants to have unique package names, so multiple versions can be installed simultaneously for testing
- I want automated version code incrementing, so I don't have to manually track build numbers
- I want the pipeline to fail if tests don't pass, so broken code doesn't get distributed

## Functional Requirements

### Build Variant Configurations

#### FR-1: Test Build Variant
1.1. **Trigger:** Pipeline must execute on pull request creation and updates
1.2. **Build Configuration:**
   - Build type: `debug`
   - Debuggable: `true`
   - Minification: Disabled
   - Shrink resources: Disabled
   - Application ID: `com.cihatakyol.sleeptimer.test`
   - Version name suffix: `-test`
   - Signing: Debug keystore (auto-generated by Android SDK)
1.3. **AdMob Configuration:**
   - Use test AdMob App ID: `ca-app-pub-3940256099942544~3347511713` (already configured)
   - Use test banner ad unit ID
   - Use test interstitial ad unit ID
1.4. **Development Features:**
   - Enable StrictMode for detecting common issues (disk/network operations on main thread)
   - Enable debug logging throughout the app
   - Enable network traffic inspection (network security config)
   - Enable LeakCanary for memory leak detection
1.5. **Distribution:**
   - Distribute via Firebase App Distribution
   - Tester group: Internal developers only
   - Include release notes from PR description

#### FR-2: Staging Build Variant
2.1. **Trigger:** Pipeline must execute on push to `develop` branch
2.2. **Build Configuration:**
   - Build type: `release` (with debuggable symbols for crash reports)
   - Debuggable: `false`
   - Minification: Enabled (R8)
   - Shrink resources: Enabled
   - Application ID: `com.cihatakyol.sleeptimer.staging`
   - Version name suffix: `-staging`
   - Signing: Staging keystore (stored in GitHub Secrets)
2.3. **AdMob Configuration:**
   - Use test AdMob App ID: `ca-app-pub-3940256099942544~3347511713`
   - Use test banner ad unit ID
   - Use test interstitial ad unit ID
2.4. **Production-Like Features:**
   - Enable Firebase Crashlytics with staging environment tag
   - Enable Firebase Analytics with staging environment flag
   - Enable Firebase Performance Monitoring
   - Disable debug logging
   - Enable R8 optimization with mapping file upload to Firebase
2.5. **Distribution:**
   - Distribute via Firebase App Distribution
   - Tester groups: Internal developers + External beta testers
   - Include release notes from commit messages

#### FR-3: Release Build Variant
3.1. **Trigger:** Pipeline must execute on push to `main`/`master` branch
3.2. **Build Configuration:**
   - Build type: `release`
   - Debuggable: `false`
   - Minification: Enabled (R8 with aggressive optimizations)
   - Shrink resources: Enabled
   - Application ID: `com.cihatakyol.sleeptimer` (base package, no suffix)
   - Version name: Semantic versioning from gradle file (e.g., `1.2.3`)
   - Signing: Production keystore (stored in GitHub Secrets)
3.3. **AdMob Configuration:**
   - Use production AdMob App ID (to be configured in build.gradle)
   - Use production banner ad unit ID
   - Use production interstitial ad unit ID
3.4. **Production Features:**
   - Enable Firebase Crashlytics with production environment tag
   - Enable Firebase Analytics (production mode)
   - Enable Firebase Performance Monitoring
   - Disable all debug features and logging
   - Enable security hardening (ProGuard rules for obfuscation)
   - Enable native code optimization if applicable
3.5. **Distribution:**
   - Build Android App Bundle (.aab) format
   - Upload to Google Play Console
   - Upload to internal testing track initially
   - Require manual promotion to production track via Play Console
   - Include What's New text from CHANGELOG or release notes

### Version Management

#### FR-4: Version Code Management
4.1. Pipeline must automatically increment `versionCode` on every successful build
4.2. Version code must be calculated as: `(base version from gradle) + (GitHub run number)`
4.3. Each build must have a unique version code to prevent conflicts

#### FR-5: Version Name Management
5.1. Version name must be manually set in `app/build.gradle.kts` file
5.2. Pipeline must read version name from gradle file
5.3. Test builds must append `-test` suffix (e.g., `1.0.0-test`)
5.4. Staging builds must append `-staging` suffix (e.g., `1.0.0-staging`)
5.5. Release builds must use the version name as-is (e.g., `1.0.0`)

### Testing Requirements

#### FR-6: Automated Testing
6.1. Pipeline must run unit tests before building
6.2. Pipeline must execute `./gradlew test` command
6.3. Test failures should NOT block the build (warning only)
6.4. Test results must be archived as workflow artifacts
6.5. Test summary must be visible in the GitHub Actions UI

### GitHub Actions Workflows

#### FR-7: Test Build Workflow
7.1. Workflow file: `.github/workflows/test-build.yml`
7.2. Triggers:
   - On pull request opened
   - On pull request synchronized (new commits)
7.3. Steps:
   - Checkout code
   - Set up JDK 17
   - Setup Android SDK
   - Grant execute permissions to gradlew
   - Run unit tests (`./gradlew testDebugUnitTest`)
   - Build test APK (`./gradlew assembleTest` or custom task)
   - Upload APK to Firebase App Distribution
   - Comment on PR with download link

#### FR-8: Staging Build Workflow
8.1. Workflow file: `.github/workflows/staging-build.yml`
8.2. Triggers:
   - On push to `develop` branch
8.3. Steps:
   - Checkout code
   - Set up JDK 17
   - Setup Android SDK
   - Decode and setup staging keystore from GitHub Secrets
   - Setup Google Services JSON from GitHub Secrets
   - Run unit tests (`./gradlew testReleaseUnitTest`)
   - Build staging APK (`./gradlew assembleStaging` or custom task)
   - Upload mapping files to Firebase Crashlytics
   - Upload APK to Firebase App Distribution
   - Create GitHub release (optional)

#### FR-9: Release Build Workflow
9.1. Workflow file: `.github/workflows/release-build.yml`
9.2. Triggers:
   - On push to `main`/`master` branch
9.3. Steps:
   - Checkout code
   - Set up JDK 17
   - Setup Android SDK
   - Decode and setup production keystore from GitHub Secrets
   - Setup Google Services JSON from GitHub Secrets
   - Run unit tests (`./gradlew testReleaseUnitTest`)
   - Build release AAB (`./gradlew bundleRelease` or custom task)
   - Upload mapping files to Firebase Crashlytics
   - Upload AAB to Google Play Console internal testing track
   - Create GitHub release with APK/AAB as artifacts
   - Require manual approval for production promotion (done via Play Console, not CI)

### Fastlane Integration

#### FR-10: Fastlane Lanes
10.1. Create Fastlane lane: `build_test` for test builds
10.2. Create Fastlane lane: `build_staging` for staging builds
10.3. Create Fastlane lane: `build_release` for release builds
10.4. Create Fastlane lane: `distribute_firebase` for Firebase App Distribution
10.5. Create Fastlane lane: `upload_play_store` for Google Play uploads

#### FR-11: Firebase App Distribution Setup
11.1. Configure Firebase App Distribution plugin in Fastlane
11.2. Use Firebase CLI token from GitHub Secrets for authentication
11.3. Specify tester groups:
   - Test builds: `internal-developers`
   - Staging builds: `internal-developers`, `beta-testers`
11.4. Include release notes in distribution

#### FR-12: Google Play Console Setup
12.1. Configure supply plugin in Fastlane for Play Store uploads
12.2. Use Google Play service account JSON from GitHub Secrets
12.3. Upload to internal testing track
12.4. Include What's New notes from CHANGELOG or commit messages
12.5. Do NOT auto-promote to production (manual approval required)

### Secrets Management

#### FR-13: Required GitHub Secrets
13.1. `STAGING_KEYSTORE_FILE`: Base64 encoded staging keystore
13.2. `STAGING_KEYSTORE_PASSWORD`: Staging keystore password
13.3. `STAGING_KEY_ALIAS`: Staging key alias
13.4. `STAGING_KEY_PASSWORD`: Staging key password
13.5. `RELEASE_KEYSTORE_FILE`: Base64 encoded production keystore
13.6. `RELEASE_KEYSTORE_PASSWORD`: Production keystore password
13.7. `RELEASE_KEY_ALIAS`: Production key alias
13.8. `RELEASE_KEY_PASSWORD`: Production key password
13.9. `GOOGLE_SERVICES_JSON`: Base64 encoded google-services.json for Firebase
13.10. `FIREBASE_TOKEN`: Firebase CLI token for App Distribution
13.11. `PLAY_STORE_SERVICE_ACCOUNT_JSON`: Google Play service account JSON
13.12. `ADMOB_APP_ID_PROD`: Production AdMob application ID
13.13. `ADMOB_BANNER_ID_PROD`: Production AdMob banner ad unit ID
13.14. `ADMOB_INTERSTITIAL_ID_PROD`: Production AdMob interstitial ad unit ID

### Build Configuration Files

#### FR-14: Gradle Build Configuration
14.1. Create build variants in `app/build.gradle.kts`:
   - `test` variant with debug build type
   - `staging` variant with release build type
   - `release` variant (default release)
14.2. Configure build config fields for each variant:
   - `ADMOB_APP_ID`
   - `ADMOB_BANNER_ID`
   - `ADMOB_INTERSTITIAL_ID`
   - `BUILD_ENVIRONMENT` (test/staging/production)
14.3. Configure signing configs for each variant
14.4. Set up ProGuard/R8 rules for release variants

#### FR-15: ProGuard/R8 Configuration
15.1. Create `proguard-rules.pro` with rules for:
   - Firebase SDK
   - AdMob SDK
   - Kotlin coroutines
   - App-specific classes that shouldn't be obfuscated
15.2. Enable mapping file generation
15.3. Configure automatic upload to Firebase Crashlytics

### Notification and Reporting

#### FR-16: Build Status Notifications
16.1. Use GitHub's native workflow notifications (email and web)
16.2. Display build status badges in README
16.3. Provide workflow status checks on pull requests

#### FR-17: Build Artifacts
17.1. Archive APK/AAB files as GitHub Actions artifacts
17.2. Retain artifacts for 90 days
17.3. Upload mapping files to Firebase Crashlytics
17.4. Archive test results and lint reports

## Non-Goals (Out of Scope)

1. **Automated UI Testing:** This PRD focuses on unit tests only; UI/instrumentation tests are out of scope
2. **Automated Production Releases:** Direct automated deployment to production track is not included; manual approval via Play Console is required
3. **Multi-Module App Support:** This PRD assumes a single-module app structure
4. **Cross-Platform CI/CD:** iOS builds and other platforms are not covered
5. **Custom Notification Channels:** Advanced notifications via Slack/Discord/Email are not included (GitHub notifications only)
6. **Rollback Mechanisms:** Automatic rollback on production issues is not included
7. **A/B Testing Integration:** Feature flags or A/B testing frameworks are not part of this pipeline
8. **Performance Benchmarking:** Automated performance testing and benchmarking are not included
9. **Security Scanning:** SAST/DAST tools and vulnerability scanning are not included in this initial version
10. **Multi-Region Deployments:** Geographic staged rollouts are not automated

## Design Considerations

### GitHub Actions Workflow Structure
- Use reusable workflows where possible to reduce duplication
- Implement caching for Gradle dependencies to speed up builds
- Use matrix builds if testing across multiple API levels (optional enhancement)

### Fastlane Configuration
- Keep Fastfile clean and maintainable with separate lanes for each task
- Use Fastlane's built-in plugins for Firebase and Google Play
- Store sensitive data in environment variables, never in code

### Build Variant Naming
- Use clear, consistent naming: `test`, `staging`, `release`
- Application ID suffixes prevent installation conflicts
- Version name suffixes make builds easily identifiable

## Technical Considerations

### Dependencies
- **GitHub Actions:** Free tier should be sufficient for this project size
- **Fastlane:** Requires Ruby environment (use setup-ruby action)
- **Firebase App Distribution:** Requires Firebase project setup
- **Google Play Console:** Requires developer account and service account setup

### Build Environment
- **JDK Version:** Java 17 (required for Android Gradle Plugin 8.x)
- **Android SDK:** API 34 (target SDK)
- **Gradle Version:** Use gradle wrapper (./gradlew) for consistency
- **Build Time:** Expected 5-15 minutes per build depending on caching

### Keystore Management
- Generate separate keystores for staging and production
- Store keystores as base64-encoded strings in GitHub Secrets
- Never commit keystores to version control
- Document keystore generation process for team reference

### Firebase Setup
- Create Firebase project if not exists
- Enable Crashlytics and App Distribution
- Generate Firebase CLI token: `firebase login:ci`
- Add `google-services.json` to project (stored in secrets for CI)

### Google Play Setup
- Create service account in Google Cloud Console
- Grant service account access to Play Console
- Download JSON key file (store in GitHub Secrets)
- Enable Play Developer API

### Gradle Configuration
- Dynamic version code: `versionCode = (baseVersionCode * 1000) + github.run_number`
- Use `buildConfigField` for environment-specific values
- Configure flavor dimensions if needed

### Security Considerations
- Rotate secrets periodically (keystores, service accounts)
- Use GitHub's secret scanning feature
- Restrict workflow permissions to minimum required
- Review and audit workflow runs regularly

## Success Metrics

### Automation Metrics
1. **Build Time Reduction:** Reduce time from commit to distributable build by 80% (from ~1 hour manual to <15 minutes automated)
2. **Build Success Rate:** Achieve >95% successful build rate for properly tested code
3. **Distribution Speed:** Test builds available within 15 minutes of PR creation

### Quality Metrics
4. **Pre-merge Defects:** Catch 100% of build-breaking issues before merge to develop
5. **Production Incidents:** Zero incidents caused by build/deployment errors
6. **Version Conflicts:** Zero installation conflicts between test/staging/production builds

### Developer Productivity Metrics
7. **Manual Interventions:** Reduce manual build/deployment steps from 15+ to 0 for test/staging
8. **Developer Satisfaction:** Positive feedback from team on pipeline reliability
9. **Time to Testing:** Reduce time from code complete to QA testing from 24 hours to <1 hour

### Release Metrics
10. **Release Frequency:** Enable daily staging releases if needed
11. **Release Confidence:** 100% of releases pass through staging before production
12. **Deployment Errors:** Zero failed production uploads due to misconfiguration

## Open Questions

1. **Firebase Project:** Does the Firebase project already exist, or does it need to be created?
2. **Google Play Developer Account:** Is the app already published on Google Play, or is this a new app submission?
3. **Tester Groups:** What are the specific email addresses or groups for internal developers and beta testers?
4. **AdMob Production IDs:** What are the actual production AdMob IDs to use (app ID, banner ID, interstitial ID)?
5. **Branch Strategy:** Is the main branch named `main` or `master`? Is the development branch named `develop` or `development`?
6. **Keystore Existing:** Do staging and production keystores already exist, or do they need to be generated?
7. **Changelog Format:** How should release notes be generated? From git commit messages, a CHANGELOG.md file, or manual input?
8. **Build Retention:** How long should builds be retained on Firebase App Distribution (default 30 days)?
9. **Staged Rollout Percentage:** When manually promoting to production, what percentage for staged rollout is preferred (10%, 25%, 50%)?
10. **Crashlytics:** Is Firebase Crashlytics already integrated, or does it need to be added?
11. **Multiple APK/AAB:** Should both APK and AAB be generated for releases, or AAB only?
12. **API Level Support:** Should the pipeline test against multiple Android API levels (e.g., API 26, 30, 34)?

## Implementation Phases (Suggested)

### Phase 1: Foundation (Week 1)
- Set up GitHub Secrets
- Create keystores (staging and production)
- Configure Firebase project and App Distribution
- Set up Google Play service account
- Create basic Fastlane configuration

### Phase 2: Test Build Pipeline (Week 1-2)
- Implement test build variant in Gradle
- Create test build GitHub Actions workflow
- Integrate Firebase App Distribution for test builds
- Test end-to-end: PR → Build → Distribution

### Phase 3: Staging Build Pipeline (Week 2)
- Implement staging build variant in Gradle
- Create staging build GitHub Actions workflow
- Configure Firebase Crashlytics integration
- Test end-to-end: Develop push → Build → Distribution

### Phase 4: Release Build Pipeline (Week 3)
- Implement release build variant in Gradle
- Create release build GitHub Actions workflow
- Integrate Google Play Console uploads
- Configure ProGuard/R8 optimization
- Test end-to-end: Main push → Build → Upload → Manual approval → Production

### Phase 5: Refinement (Week 4)
- Add build caching for faster builds
- Improve error handling and logging
- Create documentation for team
- Set up monitoring and alerts
- Conduct team training

---

**Document Version:** 1.0
**Last Updated:** 2025-11-27
**Owner:** Product/Engineering Team
**Status:** Draft - Ready for Review
